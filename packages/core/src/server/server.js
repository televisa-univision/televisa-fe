// This is needed to enable datadog tracing.
// eslint-disable-next-line
import Datadog from 'app/utils/datadog';
import createHealthcheckMiddleware from 'healthcheck-ping';
import Express from 'express';
import helmet from 'helmet';
import csp from 'helmet-csp';
import path from 'path';
import serverConfig, { getClientConfig } from 'server/config';
import appConfig from 'app/config';

import logger from 'app/utils/logging/serverLogger';

import poll from 'server/proxy/poll/poll';
import sports from 'server/proxy/sports/sports';
import weather from 'server/proxy/weather/weather';
import picture from 'server/proxy/picture/picture';
import page, { getErrorPage } from 'server/routes/page/page';
import ssoIframe, { getSsoIFrame } from 'server/routes/sso';
import ssoAcp from 'server/routes/sso/ssoAcp';
import redirect from 'server/routes/redirect';
import robots from 'server/middleware/robots';
import favicon from 'server/middleware/favicon';
import legacyClientLogging from 'server/routes/monitoring/error';
import clientLogging from 'server/routes/monitoring/clientLogging';
import comScorePageViewCandidate from 'server/routes/comscore/pageview_candidate';
import componentPage from 'server/proxy/component';
import logging from 'server/middleware/logging';
import { responseBodyParser } from 'server/middleware/bodyParser';
import getCssAssetObject from 'server/utils/inlineCss';
import assetsMiddleware from 'server/middleware/assets';

import { setHeaders, isSsoDomain } from 'server/utils/serverUtils';
import { exists, getKey } from '@univision/fe-commons/dist/utils/helpers';
import * as messages from '@univision/fe-commons/dist/constants/messages';

import ssrState from './routes/state';

/**
 * Default port the server side application listens on.
 * @type {number}
 */
const PORT = serverConfig.port;

/**
 * Gets config object for asset serving routes
 * @param {boolean} fallthrough True if middleware should call next() on failure
 * @param {number} ttl Cache headers ttl
 * @returns {{setHeaders: (function(*=)), fallthrough: boolean}}
 */
const getAssetsConfig = (fallthrough = false, ttl = 2592000) => {
  return {
    setHeaders(res) {
      setHeaders(res, ttl);
    },
    fallthrough,
  };
};

/**
 * Creates a new worker express server to listen to
 * application requests
 * @param {Object} parameters Parameters passed by universal webpack
 */
export default async function (parameters) {
  const app = new Express();

  /**
   * Disables ETAGs for the whole express server
   */
  app.set('etag', false);

  /**
   * Logging middleware for expressjs requests
   */
  app.use(logging);

  app.use(responseBodyParser);

  app.use(helmet({
    dnsPrefetchControl: { allow: false },
    frameguard: false,
    hsts: false,
  }));

  /**
   * Adds content security policy module from helmet only for lower environment
   * It only sets the upgrade-insecure-requests part of the header.
   */
  if (process.env.DEPLOY_ENV === 'test' && typeof process.env.CDN_URL !== 'undefined') {
    app.use(csp({
      directives: {
        upgradeInsecureRequests: true,
      },
    }));
  }

  /**
   * Avoids registering the proxyâ€™s IP address as the client IP
   */
  app.set('trust proxy', true);

  /**
   * Registers health check middleware with express.
   * Endpoint listens on localhost:8080/health
   */
  app.use(createHealthcheckMiddleware('health'));

  let ssrInlineCss = {};

  try {
    ssrInlineCss = await getCssAssetObject();
  } catch (e) {
    logger.error('Error loading ssr ccs cache.', e);
  }

  const assets = {
    ...parameters.chunks(),
    ssrInlineCss,
  };

  const clientConfig = getClientConfig();

  /**
   * Route for serving assets generated by webpack
   */
  app.use('/assets', assetsMiddleware, Express.static(path.join(__dirname, '../assets'), getAssetsConfig()));

  /**
   * Route for serving static assets
   */
  app.use('/', Express.static(path.join(__dirname, '../assets/public'), getAssetsConfig(true)));

  /**
   * Special route for service-worker to be served from root
   */
  app.get('/service-worker.js', (req, res) => {
    res.sendFile(path.resolve(__dirname, '../assets/service-worker.js'));
  });

  /**
   * Route for providing the Univision SSO iframe
   */
  app.use((req, res, next) => {
    req.assets = assets;
    if (isSsoDomain(req.host, req.originalUrl)) {
      // All routes will resolve to the ssoIframe
      getSsoIFrame(req, res, next);
    } else {
      next();
    }
  }, ssoIframe);

  /**
   * Route for providing the Univision SSO ACP
   */
  app.use((req, res, next) => {
    req.assets = assets;
    next();
  }, ssoAcp);

  /**
   * Route for the static version of our component
   * libraries' story books and documentation page
   */
  if (process.env.DEPLOY_ENV === 'test') {
    app.use('/storybook/base', Express.static(path.join(__dirname, '/../../../../node_modules/@univision/fe-components-base/dist/out/')));
    app.use('/storybook/commons', Express.static(path.join(__dirname, '/../../../../node_modules/@univision/fe-commons/dist/out/')));
    app.use('/storybook/core', Express.static(path.join(__dirname, '/../../dist/out/')));
    app.use('/storybook/deportes', Express.static(path.join(__dirname, '/../../../../node_modules/@univision/fe-deportes/dist/out/')));
    app.use('/storybook/icons', Express.static(path.join(__dirname, '/../../../../node_modules/@univision/fe-icons/dist/out/')));
    app.use('/storybook/local', Express.static(path.join(__dirname, '/../../../../node_modules/@univision/fe-local/dist/out/')));
    app.use('/storybook/utilities', Express.static(path.join(__dirname, '/../../../../node_modules/@univision/fe-utilities/dist/out/')));
    app.use('/storybook/video', Express.static(path.join(__dirname, '/../../../../node_modules/@univision/fe-video/dist/out/')));
    // docs
    app.use('/docs/core', Express.static(path.join(__dirname, '/../../docs/')));
    app.use('/docs/utilities', Express.static(path.join(__dirname, '/../../../../node_modules/@univision/fe-utilities/dist/docs/')));
  }

  /**
   * Serve favicon from project root directory
   */
  app.use(favicon);

  /**
   * Serves a blank page for ignored routes to avoid a flood of 404s
   */
  serverConfig.ignoredRoutes.forEach((ignored) => {
    const route = `*${ignored}*`;
    app.use(route, (req, res) => {
      res.end();
    });
  });

  /**
   * Route for submitting polls. Proxied here to avoid CORS issues.
   */
  app.use(appConfig.routes.proxy.uncached, poll);

  /**
   * Route for sports api.
   */
  app.use(appConfig.routes.proxy.cached, sports);

  /**
   * Route for weather api.
   */
  app.use(appConfig.routes.proxy.cached, weather);

  /**
   * Route for getting Picture
   */
  app.use(appConfig.routes.proxy.cached, (req, res, next) => {
    req.clientConfig = clientConfig;
    next();
  }, picture);

  /**
   * Route for legacy client logging
   */
  app.use(appConfig.routes.proxy.cached, legacyClientLogging);

  /**
   * Route for client logging
   */
  app.use(appConfig.routes.proxy.uncached, clientLogging);

  /**
   * Route for client logging
   */
  app.use(appConfig.routes.proxy.cached, comScorePageViewCandidate);

  /**
   * Component route to render isolated component for mobile webviews
   */
  app.use(appConfig.routes.proxy.cached, (req, res, next) => {
    req.assets = assets;
    next();
  }, componentPage);

  /**
   * Middleware for responding to requests for the web application's robot.txt
   */
  app.use((req, res, next) => {
    req.robots = path.join(__dirname, '/../assets/text/robots.txt');
    next();
  }, robots);

  /**
   * Redirect route for TUDN origin to Akamai (www)
   */
  app.use(redirect);

  app.use(appConfig.routes.proxy.cached, (req, res, next) => {
    req.assets = assets;
    req.clientConfig = clientConfig;
    next();
  }, ssrState);

  /**
   * Default route where the rendering of the React components will happen
   */
  app.use((req, res, next) => {
    req.assets = assets;
    req.clientConfig = clientConfig;
    next();
  }, page);

  /**
   * If no middleware handles the request send 404 by default
   */
  app.use((req, res, next) => {
    const err = new Error('Not Found');
    err.statusCode = 404;
    next(err);
  });

  /**
   * Registers an optional fallthrough error handler for the exception
   * monitoring library to use to report errors and for the application
   * to display an error message/page to the user.
   */
  app.use(async (err, req, res, next) => {
    if (!exists(res)) {
      next(err);
      return;
    }

    const statusCode = getKey(err, 'statusCode', 500);

    // Do nothing if we have already sent the headers
    if (!res.headersSent) {
      res.stack = err.stack;
      res.errorMessage = err.message || `Something went wrong: ${err?.message} - serving url: ${req.originalUrl}`;
      try {
        const html = await getErrorPage(req, assets);
        res.status(statusCode)
          .send(html);
      } catch (e) {
        res.status(statusCode)
          .send(messages.INTERNAL_ERROR);
      }
    } else {
      logger.warn('Headers have already been sent for this request. Ignoring default error route.');
    }
  });

  /**
   * Starts the server, listening on the port configured on serverConfig
   */
  const server = app.listen(PORT, (err) => {
    if (err) {
      logger.error(err);
    } else {
      const startMessage = `>>> Worker started listening on port ${PORT}!`;
      logger.info(startMessage);
    }
  });
  server.keepAliveTimeout = 60000 * 2;

  process.on('SIGTERM', () => {
    logger.info('SIGTERM signal received.');

    server.close((err) => {
      if (err) {
        logger.error(err);
        process.exit(1);
      } else {
        process.exit(0);
      }
    });
  });
}
